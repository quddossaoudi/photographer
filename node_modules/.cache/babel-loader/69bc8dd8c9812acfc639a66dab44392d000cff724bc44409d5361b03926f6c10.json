{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nfunction useOnScreen(ref) {\n  _s();\n  let threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.3;\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n  useEffect(() => {\n    const observer = new IntersectionObserver(_ref => {\n      var _entry$isIntersecting;\n      let [entry] = _ref;\n      // Update our state when observer callback fires\n      setIntersecting((_entry$isIntersecting = entry === null || entry === void 0 ? void 0 : entry.isIntersecting) !== null && _entry$isIntersecting !== void 0 ? _entry$isIntersecting : false);\n    }, {\n      rootMargin: \"0px\",\n      threshold\n    });\n    const currentRef = ref.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [ref, threshold]); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}\n_s(useOnScreen, \"+TWZGT8mxcpNH+JS7IkSFv1hR0A=\");\nexport default useOnScreen;","map":{"version":3,"names":["useState","useEffect","useOnScreen","ref","_s","threshold","arguments","length","undefined","isIntersecting","setIntersecting","observer","IntersectionObserver","_ref","_entry$isIntersecting","entry","rootMargin","currentRef","current","observe","unobserve"],"sources":["/Users/Quddos/Desktop/photographer/src/hooks/useOnScreen.js"],"sourcesContent":["import { useState, useEffect } from \"react\";\n\nfunction useOnScreen(ref, threshold = 0.3) {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry?.isIntersecting ?? false);\n      },\n      {\n        rootMargin: \"0px\",\n        threshold,\n      }\n    );\n    const currentRef = ref.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [ref, threshold]); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}\nexport default useOnScreen;\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAE3C,SAASC,WAAWA,CAACC,GAAG,EAAmB;EAAAC,EAAA;EAAA,IAAjBC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,GAAG;EACvC;EACA,MAAM,CAACG,cAAc,EAAEC,eAAe,CAAC,GAAGV,QAAQ,CAAC,KAAK,CAAC;EAEzDC,SAAS,CAAC,MAAM;IACd,MAAMU,QAAQ,GAAG,IAAIC,oBAAoB,CACvCC,IAAA,IAAa;MAAA,IAAAC,qBAAA;MAAA,IAAZ,CAACC,KAAK,CAAC,GAAAF,IAAA;MACN;MACAH,eAAe,EAAAI,qBAAA,GAACC,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEN,cAAc,cAAAK,qBAAA,cAAAA,qBAAA,GAAI,KAAK,CAAC;IACjD,CAAC,EACD;MACEE,UAAU,EAAE,KAAK;MACjBX;IACF,CAAC,CACF;IACD,MAAMY,UAAU,GAAGd,GAAG,CAACe,OAAO;IAC9B,IAAID,UAAU,EAAE;MACdN,QAAQ,CAACQ,OAAO,CAACF,UAAU,CAAC;IAC9B;IACA,OAAO,MAAM;MACX,IAAIA,UAAU,EAAE;QACdN,QAAQ,CAACS,SAAS,CAACH,UAAU,CAAC;MAChC;IACF,CAAC;EACH,CAAC,EAAE,CAACd,GAAG,EAAEE,SAAS,CAAC,CAAC,CAAC,CAAC;;EAEtB,OAAOI,cAAc;AACvB;AAACL,EAAA,CA3BQF,WAAW;AA4BpB,eAAeA,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}